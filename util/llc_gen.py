#!/usr/bin/env python3

import math
import argparse
import hjson
import sys
import pathlib
import re
import logging
from jsonref import JsonRef
from mako.template import Template
from gen_support import *

# Compile a regex to trim trailing whitespaces on lines
re_trailws = re.compile(r'[ \t\r]+$', re.MULTILINE)

# Convert integer to hex string
def int2hexstr(n, nbits) -> str:
    return hex(n)[2:].zfill(nbits//4).upper()

def write_template(tpl_path, outdir, **kwargs):
    if tpl_path is not None:
        tpl_path = pathlib.Path(tpl_path).absolute()
        if tpl_path.exists():
            tpl = Template(filename=str(tpl_path))
            with open(outdir / tpl_path.with_suffix("").name, 'w', encoding='utf-8') as f:
                code = tpl.render_unicode(**kwargs)
                code = re_trailws.sub('', code)
                f.write(code)
        else:
            raise FileNotFoundError(f'Template file {tpl_path} not found')
    

def main():
    # Parser for command line arguments
    parser = argparse.ArgumentParser(prog='l1-gen.py', description='Generate C/HJSON/SystemVerilog configuration files.')
    parser.add_argument('--cfg', 
                        '-c', 
                        metavar='FILE',
                        type=argparse.FileType('r'),
                        required=True,
                        help='Configuration file in HJSON format')
    parser.add_argument('--enc', 
                        '-e', 
                        metavar='FILE',
                        type=str,
                        help='encoding.out.h file generated by riscv-opcodes')
    parser.add_argument('--outdir',
                        '-o',
                        metavar='DIR',
                        type=pathlib.Path,
                        required=True,
                        help='Output directory')
    parser.add_argument('--tpl-sv',
                        '-s',
                        type=str,
                        metavar='SV',
                        help='SystemVerilog template filename')
    parser.add_argument('--tpl-c',
                        '-C',
                        type=str,
                        metavar='C_SOURCE',
                        help='C template filename')
    parser.add_argument('--tpl-hjson',
                        '-H',
                        type=str,
                        metavar='HJSON',
                        help='Hjson template filename')
    parser.add_argument('--verbose',
                        '-v',
                        action='store_true',
                        help='Increase verbosity')
    args = parser.parse_args()

    # Set verbosity level
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    # Read HJSON configuration file
    with args.cfg as f:
        try:
            cfg = hjson.load(f, use_decimal=True)
            cfg = JsonRef.replace_refs(cfg)
        except ValueError as exc:
            raise SystemExit(sys.exc_info()[1]) from exc
        
    # Check if the output directory is valid
    if not args.outdir.is_dir():
        exit(f'Output directory {args.outdir} is not a valid path')

    # Create output directory
    args.outdir.mkdir(parents=True, exist_ok=True)

    # Kernels
    kernels = []
    for i in range(cfg["max_kernels"]):
        kernels.append(
            Kernel(
                f'kernel{i}',
                f'Kernel {i}'
            )
        )
    
    # Arguments
    kernel_args = []
    for i, csr_address in enumerate(cfg["val_args"]["address"]):
        kernel_args.append(
            Arg(
                f'arg{i}',
                f'Argument {i}',
                csr_address
            )
        )
    
    # Reference Arguments
    kernel_ref_args = []
    for i in range(cfg["max_ref_args"]):
        kernel_ref_args.append(
            RefArg(
                f'refarg{i}',
                f'Reference Argument {i}'
            )
        )
    
    # Parse the encoding file (if given)
    if args.enc is not None:
        parseEncodingFile(args.enc, kernels)


    
    # CORE-V-MINI-MCU configuration
    # -----------------------------
    cpu = cfg['cpu']
    # Controller subsystem 
    #---------------------
    # Configuration registers
    cfg_reg_num =   int(cfg['cfg_regs']['num']) +\
                    int(cfg["max_kernels"]) +\
                    int(cfg["max_ref_args"]) +\
                    int(len(cfg["val_args"]["address"]))


    # Emem
    emem_start_address = int(cfg['emem']['offset'], 16)
    emem_start_address_hex = int2hexstr(emem_start_address, 32)
    emem_size = int(cfg['emem']['length'], 16)
    emem_size_hex = int2hexstr(emem_size, 32)
    emem_runtime_size = int(cfg['emem']['sections_size']['runtime'], 16)
    emem_data_size = int(cfg['emem']['sections_size']['data'], 16)
    emem_kernels_size = int(cfg['emem']['sections_size']['kernels'], 16)
    emem_stack_size = int(cfg['emem']['sections_size']['stack'], 16)

    
    # Configuration registers
    cfg_reg_start_address = emem_start_address + emem_size
    cfg_reg_start_address_hex = int2hexstr(cfg_reg_start_address, 32)
    cfg_reg_size = int(cfg['cfg_regs']['size'])
    cfg_reg_size_hex = int2hexstr(cfg_reg_size, 32)
    # L1 subsystem 
    #-------------
    # NM-Carus number of instances and configuration
    carus_num = int(cfg['l1']['carus']['num'])
    if carus_num < 0 or carus_num > 16:
        exit(f'NM-Carus instances number must be <16: {carus_num}')
    carus_num_banks = int(cfg['l1']['carus']['num_banks'])

    # Main Memory number of banks and configuration
    main_mem_ports = int(cfg['main_memory']['num_ports'])
    if main_mem_ports < 0:
        exit(f'Main memory ports must be >0: {main_mem_ports}')
    main_mem_num_banks = int(cfg['main_memory']['num_banks'])

    # Subsystem Bus configuration
    #xbar_nmasters = int(cfg['ext_xbar_masters'])
    xbar_nslaves = carus_num + main_mem_ports
    subsystem_bus_type = cfg['l1']['bus_type']
    
    # Slaves map
    carus_start_address = int(cfg['l1']['offset'], 16)
    carus_start_address_hex = int2hexstr(carus_start_address, 32)
    l1_size = int(cfg['l1']['length'], 16) # - emem_start_address
    carus_size = l1_size // carus_num
    carus_size_hex = int2hexstr(carus_size, 32)
    
    main_mem_start_address = int(cfg['main_memory']['offset'], 16)
    main_mem_start_address_hex = int2hexstr(main_mem_start_address, 32)
    main_mem_bank_size = int(cfg['main_memory']['length'], 16)//main_mem_num_banks
    main_mem_bank_size_hex = int2hexstr(main_mem_bank_size, 32)


    # DMA configuration
    dma_reg_num = int(cfg['dma_regs']['num'])
    dma_reg_start_address = cfg_reg_start_address + cfg_reg_size
    dma_reg_start_address_hex = int2hexstr(dma_reg_start_address, 32)
    dma_reg_size = int(cfg['dma_regs']['size'])
    dma_reg_size_hex = int2hexstr(dma_reg_size, 32)

    # Cache configuration
    cache_block_size = int(cfg['cache_table']['block_size'])
    #cache_num_lines = carus_num *32    # TODO: hardwired for now
    cache_num_ways = int(cfg['cache_table']['ways'])
    cache_num_sets = int(cfg['cache_table']['sets'])
    cache_num_lines = cache_num_ways * cache_num_sets
    cache_num_status = int(cfg['cache_table']['status'])
    cache_word_size = int(cfg['cache_table']['word_size'])
    cache_start_address = dma_reg_start_address + dma_reg_size
    cache_start_address_hex = int2hexstr(cache_start_address, 32)
    cache_tag_width = 32 - int(math.log2(cache_block_size)) - int(math.log2(cache_num_sets)) - int(cache_word_size/8)
    cache_table_tag_mask = hex(int("1"*int(math.log2(cache_block_size)),2))
    cache_table_reg_size = int(cfg['cache_table']['size'])
    cache_table_reg_size_hex = int2hexstr(cache_table_reg_size, 32)
    # Addr table configuration
    addr_table_num_lines = int(cfg['addr_table']['num_lines'])    
    addr_table_start_address = cache_start_address + cache_table_reg_size
    addr_table_start_address_hex = int2hexstr(addr_table_start_address, 32)
    addr_table_reg_size_hex = int2hexstr(int(cfg['addr_table']['size']), 32)

    # TODO: when carus is added, uncomment and look if some other checks are missing
    # Cache checks
    if not math.log2(cache_block_size).is_integer():
        exit(f'Cache block size must be a power of 2: {cache_block_size}')
    #if (cache_block_size!=carus_size/32):
    #    exit(f'Cache block size must be equal to Carus size: {cache_block_size}')
    #if (cache_num_lines!=carus_num*32):
    #    exit(f'Cache Num lines size must be equal to Carus num banks per carus num regs: {cache_num_lines}')
    
    # Carus checks
    # Dependent parameters
    if(subsystem_bus_type != "NtoM" and subsystem_bus_type != "onetoM"):
        exit(f'Invalid subsystem bus type: {subsystem_bus_type}')
    if not math.log2(carus_size).is_integer():
        exit(f'Carus size must be a power of 2: {carus_size}')
    if not math.log2(carus_num_banks).is_integer():
        exit(f'Carus number of banks must be a power of 2: {carus_num_banks}')
    if carus_size % carus_num_banks != 0:
        exit(f'Carus size must be a multiple of the number of banks: {carus_size} % {carus_num_banks} != 0')
    carus_bank_addr_width = int(math.ceil(math.log2(carus_size // carus_num_banks)))
    # Memory checks
    if not math.log2(main_mem_bank_size).is_integer():
        exit(f'Main Memory size must be a power of 2: {main_mem_bank_size}')
    if not math.log2(main_mem_ports).is_integer():
        exit(f'Main Memory number of ports must be a power of 2: {main_mem_ports}')
    if not math.log2(main_mem_num_banks).is_integer():
      exit(f'Main Memory number of banks must be a power of 2: {main_mem_num_banks}')
    if main_mem_num_banks % main_mem_ports != 0:
        exit(f'Main Memory number of banks must be a multiple of the number of ports: {main_mem_num_banks} % {main_mem_ports} != 0')
    if carus_start_address < main_mem_start_address + (main_mem_num_banks*main_mem_bank_size):
        exit(f"Main Memory start address must be greater than the last Carus address: {main_mem_start_address}")
    main_mem_bank_addr_width = int(math.ceil(math.log2(main_mem_bank_size)))
    

    # Emem sections size check
    if (emem_runtime_size + emem_data_size + emem_kernels_size + emem_stack_size > emem_size):
        exit(f'Emem runtime, data and kernels sections must be less than Emem size: {emem_runtime_size} + {emem_data_size} + {emem_stack_size} + {emem_kernels_size} > {emem_size}')
    if (emem_runtime_size == 0):
        exit(f'Emem runtime section size must be greater than 0: {emem_runtime_size}')
    if (emem_data_size == 0):
        exit(f'Emem data section size must be greater than 0: {emem_data_size}')
    if (emem_kernels_size == 0):
        exit(f'Emem kernels section size must be greater than 0: {emem_kernels_size}')
    if (emem_stack_size == 0):
        exit(f'Emem stack section size must be greater than 0: {emem_stack_size}')



    # Explicit arguments
    kwargs = {
        "log2_max_concurrent_kernels" : int(math.ceil(math.log2(cfg["max_concurrent_kernels"]))),
        "log2_max_kernels" : int(math.ceil(math.log2(cfg["max_kernels"]))),
        "log2_max_val_args" : int(math.ceil(math.log2(len(kernel_args)))),
        "vpu_number" : carus_num,
        "kernels" : kernels,
        "args" : kernel_args,
        "ref_args" : kernel_ref_args,
        "xlen" : cfg["xlen"],
        'cpu_corev_pulp': int(cpu['corev_pulp']),
        'cpu_corev_xif': int(cpu['corev_xif']),
        'cpu_fpu': int(cpu['fpu']),
        'cpu_riscv_zfinx': int(cpu['riscv_zfinx']),
        'xbar_nslaves': xbar_nslaves,
        'subsystem_bus_type': subsystem_bus_type,
        'main_mem_ports': main_mem_ports,
        'main_mem_bank_addr_width': main_mem_bank_addr_width,
        'main_mem_start_address': main_mem_start_address_hex,
        'main_mem_bank_size': main_mem_bank_size_hex,
        'carus_num': carus_num,
        'carus_num_banks': carus_num_banks,
        'carus_bank_addr_width': carus_bank_addr_width,
        'carus_start_address': carus_start_address_hex,
        'carus_size': carus_size_hex,
        'cache_block_size': cache_block_size,
        'cache_tag_width': cache_tag_width,
        'log2_cache_block_size': int(math.log2(cache_block_size)),
        'cache_start_address': cache_start_address_hex,
        'cache_num_lines': cache_num_lines,
        'cache_num_status': cache_num_status,
        'cache_num_ways': cache_num_ways,
        'cache_num_sets': cache_num_sets,
        'cache_word_size': cache_word_size,
        'cache_reg_size': cache_table_reg_size_hex,
        'addr_table_start_address': addr_table_start_address_hex,
        'addr_table_num_lines': addr_table_num_lines,
        'addr_table_reg_size': addr_table_reg_size_hex,
        'cfg_reg_num': cfg_reg_num,
        'cfg_reg_start_address': cfg_reg_start_address_hex,
        'cfg_reg_size': cfg_reg_size_hex,
        'dma_reg_num': dma_reg_num,
        'dma_reg_start_address': dma_reg_start_address_hex,
        'dma_reg_size': dma_reg_size_hex,
        'emem_start_address': emem_start_address_hex,
        'emem_size': emem_size_hex,
        'emem_runtime_size': emem_runtime_size,
        'emem_data_size': emem_data_size,
        'emem_kernels_size': emem_kernels_size,
        'emem_stack_size': emem_stack_size,
        'cache_table_tag_mask' : cache_table_tag_mask
    }

    # Generate SystemVerilog package
    if args.tpl_sv is not None:
        write_template(args.tpl_sv, args.outdir, **kwargs)

    # Generate C header
    if args.tpl_c is not None:
        write_template(args.tpl_c, args.outdir, **kwargs)

    # Generate HJSON header
    if args.tpl_hjson is not None:
        write_template(args.tpl_hjson, args.outdir, **kwargs)

if __name__ == '__main__':
    main()
