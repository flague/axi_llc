module axi_llc_status_reg_wrap #(
    parameter type reg_req_t = logic,
    parameter type reg_rsp_t = logic,
    parameter axi_llc_pkg::llc_cfg_t Cfg = axi_llc_pkg::llc_cfg_t'{default: '0},
    parameter int unsigned DataWidth    = 32'd128,  // Data signal width
    parameter int unsigned ByteWidth    = 32'd8,    // Width of a data byte
    parameter int unsigned NumPorts     = 32'd1,    // Number of read and write ports
    parameter int unsigned Latency      = axi_llc_pkg::TagMacroLatency,    // Latency when the read data is available
    parameter              SimInit      = "none",   // Simulation initialization
    parameter bit          PrintSimCfg  = 1'b0,     // Print configuration
    localparam int unsigned NSets = ${cache_num_sets},
    localparam int unsigned NWays = ${cache_num_ways}
) (

  input logic clk_i,
  input logic rst_ni,
  // SW interface
  input  reg_req_t reg_req_i,
  output reg_rsp_t reg_rsp_o,
  // HW interface
  input  logic [NWays-1:0] ram_req_i,
  input  logic [NWays-1:0] ram_we_i,
  input  logic [Cfg.IndexLength-1:0] ram_addr_i,
  input  logic [DataWidth-1:0] ram_wdata_i,
  output logic [NWays-1:0][DataWidth-1:0] ram_rdata_o
);

  // Internal structures
  // -------------------
  typedef struct packed {
    logic [DataWidth-1:0] status; // Status field, DataWidth = Cfg.StatusTypes
    logic qe;              // Valid bit
    logic re;              // Read enable
  } status_reg_t;

  // Internal signals
  // ----------------
  axi_llc_status_reg_pkg::axi_llc_status_hw2reg_t hw2reg;
  axi_llc_status_reg_pkg::axi_llc_status_reg2hw_t reg2hw;
  
  logic ram_hw_req; // HW request for the status store
  // Address translator
  logic [Cfg.IndexLength-1:0] ram_index;
  logic [Cfg.IndexLength-1:0] ram_sw_index;
  logic [NWays-1:0] ram_req;
  logic [NWays-1:0] ram_sw_req;
  logic [NWays-1:0] ram_we;
  logic [NWays-1:0] ram_sw_we;
  

  status_reg_t [NWays-1:0][NSets-1:0] rline_status; 
  logic [DataWidth-1:0] ram_wdata;
  logic [DataWidth-1:0] ram_sw_wdata; // TODO: define correct width
  logic [NWays-1:0][DataWidth-1:0] ram_rdata; // Read data from the status store
  // Remap hw2reg and reg2hw to the cache_table_reg_top module
  // Make the signal compatible with cache_table_reg_hw2reg of cache_table_reg_pkg (autogenerated by regtool)
  // reg2hw q and qe coming from the sw need to go to the tc_sram
  // q and qe have idx, that is the cache line. Need to translate into the ram addr

  // -------------------
  // Address translation
  // -------------------
  // Use intermediate signal to have more readable representation of set associativity
  % for idx in range(cache_num_lines):
  <%
    # NOTE: i is the way index, j is the set index
    i = int(idx/cache_num_sets)
    j = idx%cache_num_sets 
  %>

  assign rline_status[${i}][${j}].status = reg2hw.status_${idx}.q;//status_reg_t'(reg2hw.status_${idx}.q);
  assign rline_status[${i}][${j}].qe     = reg2hw.status_${idx}.qe;
  assign rline_status[${i}][${j}].re     = reg2hw.status_${idx}.re;

 % endfor
  
  logic [NWays-1:0][NSets-1:0] status_qe; // Valid bits for the status registers
  logic [NWays-1:0][NSets-1:0] status_re; // Valid bits for the status registers
  

  always_comb begin
    ram_sw_index = '0; // Default value for the software index
    ram_sw_wdata = '0; // Default value for the software write data
    // Initialize the tag and status valid bits
    for (int i = 0; i < NWays; i++) begin
      for (int j = 0; j < NSets; j++) begin
        if (rline_status[i][j].qe == 1'b1) begin
          ram_sw_index = logic'(j);
          ram_sw_wdata = rline_status[i][j].status;
        end  
      end
    end
  end
  generate
    for (genvar i = 0; i < NWays; i++) begin : gen_way
      assign ram_sw_we[i] = |status_qe[i]; // Write enable for the tag store
      assign ram_sw_req[i] = (|status_qe[i]) | (|status_re[i]);                        
      for (genvar j = 0; j < NSets; j++) begin : gen_set
        assign status_qe[i][j] = rline_status[i][j].qe;
        assign status_re[i][j] = rline_status[i][j].re;
      end

    end
  endgenerate
  // Mux write requests with HW interface
  // ------------------------------------
  assign ram_hw_req = |ram_req_i; // HW request for the way i
  generate
  for (genvar i = 0; i < NWays; i++) begin : gen_mux
      assign ram_req[i] = ram_sw_req[i] || ram_req_i[i]; // Combine SW and HW requests
      assign ram_we[i]  = ram_req_i[i] ? ram_we_i[i] : ram_sw_we[i];
  end
  endgenerate
  // Write and read data
  assign ram_index = ram_hw_req ? ram_addr_i  : ram_sw_index; // Assuming ram_index is the index part of the address
  assign ram_wdata = ram_hw_req ? ram_wdata_i : ram_sw_wdata;
  assign ram_rdata_o = ram_rdata; // Read data from the tag store (no data gating)


  // Read port of memory
  // -------------------
  // Mem has a single read port, so we have that whatever set has the same d.
  // Should not be a problem as d = qs and the correct set output should be selected 
  % for idx in range(cache_num_lines):
  <%
    # NOTE: i is the way index, j is the set index
    i = int(idx/cache_num_sets)
    j = idx%cache_num_sets
  %>
  assign hw2reg.status_${idx}.d    = ram_rdata[${i}];
  % endfor

  //-------------
  // Way Memories
  //-------------
  for (genvar i = 0; unsigned'(i) < NWays; i++) begin : gen_status_macros
    tc_sram #(
      .NumWords    ( NSets                ),
      .DataWidth   ( DataWidth                   ),
      .ByteWidth   ( ByteWidth                   ),
      .NumPorts    ( 32'd1                        ),
      .Latency     ( axi_llc_pkg::TagMacroLatency ),
      .SimInit     ( "none"                       ),
      .PrintSimCfg ( PrintSimCfg                 )
    ) i_status_store (
      .clk_i,
      .rst_ni,
      .req_i   ( ram_req[i] ),
      .we_i    ( ram_we[i]  ),
      .addr_i  ( ram_index  ),
      .wdata_i ( ram_wdata  ),
      .be_i    ( ram_we[i]  ),
      .rdata_o ( ram_rdata[i] )
    );
 end


  //-------------------
  // Register interface
  //-------------------
  axi_llc_status_reg_top #(
    .reg_req_t(reg_req_t),
    .reg_rsp_t(reg_rsp_t)
  ) axi_llc_status_reg_top_i (
    .clk_i,
    .rst_ni,
    .reg_req_i,
    .reg_rsp_o,
    .reg2hw,
    .hw2reg,
    .devmode_i(1'b1)
  );

  //-----------
  // Assertions
  //-----------
  `ifndef VERILATOR
  `ifndef SYNTHESIS
  // check there is never a request from eCPU and a req to the tc_sram at the same time
  check_no_conflict: assert property (
    @(posedge clk_i) disable iff (!rst_ni)
    !(reg_req_i.req && ram_hw_req)) else $fatal(1, "There is a conflict between the eCPU request and the tc_sram request!");
  // Less restrictive assertions on requests
  // Do not exclude concurrent read
  check_no_conflict_w: assert property (
    @(posedge clk_i) disable iff (!rst_ni)
    !(reg_req_i.req && reg_req_i.wdata && ram_hw_req && ~(|ram_we_i)) || !(reg_req_i.req && !reg_req_i.wdata && ram_hw_req && |ram_we_i)) 
    else $fatal(1, "There is a conflict between the eCPU write request and the tc_sram request!");
  `endif
  `endif

endmodule
